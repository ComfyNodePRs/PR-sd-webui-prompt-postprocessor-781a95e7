from collections import namedtuple
import re
import math
import lark


class PromptPostProcessor:  # pylint: disable=too-few-public-methods,too-many-instance-attributes
    """
    The PromptPostProcessor class is responsible for processing and manipulating prompt strings.

    Attributes:
        NAME (str): The name of the prompt post-processor.
        VERSION (str): The version of the prompt post-processor.
        DEFAULT_STN_SEPARATOR (str): The default separator used for content sent to the negative prompt.

    Methods:
        __init__(self, script, opts=None, is_i2i=False): Initializes the PromptPostProcessor instance.
        formatOutput(self, text: str) -> str: Formats the output text by encoding and decoding it.
        STNTree: A nested class for interpreting and processing a tree generated by the prompt parser.
        __find_tags(self, prompt): Finds tags in the given prompt and returns the modified prompt and tag information.
        __add_to_insertion_points(self, negative_prompt, add_at_insertion_point): Adds the negative prompt to the insertion points.
        __add_to_start(self, negative_prompt, add_at_start): Adds the elements in `add_at_start` list to the start of the `negative_prompt` string.
        __add_to_end(self, negative_prompt, add_at_end): Adds the elements in `add_at_end` list to the end of `negative_prompt` string.
        CleanupTree: A nested class for cleaning up a prompt parsed into a tree.
        __cleanup(self, prompt, negative_prompt): Cleans up the prompt and negative prompt by removing extra spaces, empty constructs, and extra separators.
        cleanup_text(self, text): Cleans up the given text by removing extra separators, breaks, and spaces.
        trim_text(self, text): Trims the given text based on the specified cleanup options.
        process_prompt(self, original_prompt, original_negative_prompt): Process the prompt and negative prompt by moving content to the negative prompt, and cleaning up.
    """

    NAME = "Prompt Post-Processor"
    VERSION = "2.4.0"

    DEFAULT_STN_SEPARATOR = ", "
    IFWILDCARDS_CHOICES = {
        "ignore": "Ignore",
        "remove": "Remove",
        "warn": "Add visible warning",
        "stop": "Stop the generation",
    }
    WILDCARD_WARNING = '(WARNING TEXT "INVALID WILDCARD" IN BRIGHT RED:1.5)\nBREAK '
    WILDCARD_STOP = "INVALID WILDCARD!\nBREAK "
    UNPROCESSED_STOP = "UNPROCESSED CONSTRUCTS!\nBREAK "

    def __init__(
        self,
        script,
        processing,
        state,
        opts=None,
        is_i2i=False,
    ):
        """
        Initializes the PPP object.

        Args:
            script: The script object.
            opts: Optional. The options object for configuring PPP behavior.
        """
        self.script = script
        self.logger = script.ppp_logger
        self.opts = opts
        self.is_i2i = is_i2i
        self.processing = processing
        self.state = state
        self.variables = {}
        self.debug = getattr(self.opts, "ppp_gen_debug", False) if opts is not None else False
        if opts is not None and getattr(opts, "prompt_attention", "") == "Compel parser":
            self.logger.warning("Compel parser is not supported!")
        self.ifwildcards = (
            getattr(opts, "ppp_gen_ifwildcards", self.IFWILDCARDS_CHOICES["ignore"])
            if opts is not None
            else self.IFWILDCARDS_CHOICES["ignore"]
        )

        self.stn_doi2i = getattr(opts, "ppp_stn_doi2i", False) if opts is not None else False
        self.stn_ignore_repeats = getattr(opts, "ppp_stn_ignorerepeats", True) if opts is not None else True
        self.stn_join_attention = getattr(opts, "ppp_stn_joinattention", True) if opts is not None else True
        self.stn_separator = (
            getattr(opts, "ppp_stn_separator", self.DEFAULT_STN_SEPARATOR)
            if opts is not None
            else self.DEFAULT_STN_SEPARATOR
        )

        self.cup_doi2i = getattr(opts, "ppp_cup_doi2i", False) if opts is not None else False
        self.cup_extraspaces = getattr(opts, "ppp_cup_extraspaces", True) if opts is not None else True
        self.cup_emptyconstructs = getattr(opts, "ppp_cup_emptyconstructs", True) if opts is not None else True
        self.cup_extraseparators = getattr(opts, "ppp_cup_extraseparators", True) if opts is not None else True
        self.cup_extraseparators2 = getattr(opts, "ppp_cup_extraseparators2", True) if opts is not None else True
        self.cup_breaks = getattr(opts, "ppp_cup_breaks", True) if opts is not None else True
        self.cup_breaks_eol = getattr(opts, "ppp_cup_breaks_eol", False) if opts is not None else False
        self.cup_ands = getattr(opts, "ppp_cup_ands", True) if opts is not None else True
        self.cup_ands_eol = getattr(opts, "ppp_cup_ands_eol", False) if opts is not None else False
        self.cup_extranetworktags = getattr(opts, "ppp_cup_extranetworktags", False) if opts is not None else False
        self.rem_removeextranetworktags = (
            getattr(opts, "ppp_rem_removeextranetworktags", False) if opts is not None else False
        )
        # Process with lark (debug with https://www.lark-parser.org/ide/)
        self.__parser_complete = lark.Lark(
            r"""
                start: (promptcomp | specialchars)*

                // prompt composition with AND
                promptcomp: promptcomppart ([":" numpar] (/\bAND\b/ promptcomppart [":" numpar])+)?
                promptcomppart: prompt

                // prompt scheduling and alternation
                alternate: "[" alternateoption ("|" alternateoption)+ "]"
                alternateoption: prompt
                scheduled: "[" [prompt ":"] prompt ":" numpar "]"

                // wildcard extension support
                wildcard: "__" /(?:(?!__)\S)+/ "__"
                choices: "{" choice ("|" choice)* "}"
                // we ignore weight and any other parameters in each choice
                choice: prompt

                // simple prompts
                prompt: (emphasized | deemphasized | scheduled | alternate | extranetworktag | commandstn | commandstni | negtag | commandset | commandif | commandecho | wildcard | choices | plain)*

                nonegprompt: (emphasized | deemphasized | scheduled | alternate | extranetworktag | commandset | commandif | commandecho | wildcard | choices | plain)*
                
                // attention modifiers
                emphasized: "(" prompt [":" numpar] ")"
                deemphasized: "[" prompt "]"

                // extra network tags
                extranetworktag: "<" /(?!!|ppp:)[^>]+/ ">"

                // negative tags
                negtag: "<!" [negtagparameters] nonegprompt "!>"
                negtagparameters: "!" /s|e|[ip]\d/ "!"

                // command: stn (send to negative)
                commandstn: "<ppp:stn" [WHITESPACE /s|e|p\d/] WHITESPACE? ">" nonegprompt "<ppp:/stn>"
                commandstni: "<ppp:stn" WHITESPACE /i\d/ WHITESPACE? ">"

                // command: if
                commandif: commandif_if commandif_elif* commandif_else? "<ppp:/if>"
                commandif_if: "<ppp:if" WHITESPACE condition WHITESPACE? ">" prompt
                commandif_elif: "<ppp:elif" WHITESPACE condition WHITESPACE? ">" prompt
                commandif_else: "<ppp:else" WHITESPACE? ">" prompt
                condition: IDENTIFIER WHITESPACE /eq|ne|gt|lt|ge|le/ WHITESPACE VALUE
                IDENTIFIER: CNAME
                VALUE: STRING | INT

                // command: set
                commandset: "<ppp:set" WHITESPACE IDENTIFIER WHITESPACE? ">" prompt "<ppp:/set>"

                // command: echo
                commandecho: "<ppp:echo" WHITESPACE IDENTIFIER WHITESPACE? ">"

                // plain text and weights
                numpar: WHITESPACE? NUMBER WHITESPACE?
                WHITESPACE: /\s+/
                STRING: /("(?!"").*?(?<!\\)(\\\\)*?"|'(?!'').*?(?<!\\)(\\\\)*?')/i
                plain: /((?!__|\bAND\b)[^\\[\]():|<>!{}]|\\.)+/s
                specialchars: /[\]():|<>!{}]|\bAND\b/+
                %import common.SIGNED_NUMBER -> NUMBER
                %import common.CNAME -> CNAME
                %import common.INT -> INT
            """,
            propagate_positions=True,
        )

    def formatOutput(self, text: str):
        """
        Formats the output text by encoding it using unicode_escape and decoding it using utf-8.

        Args:
            text (str): The input text to be formatted.

        Returns:
            str: The formatted output text.
        """
        return text.encode("unicode_escape").decode("utf-8")

    def eval_condition(self, cond_var, cond_comp, cond_value):
        """
        Evaluate a condition based on the given variable, comparison, and value.

        Args:
            cond_var (str): The variable to be compared.
            cond_comp (str): The comparison operator.
            cond_value (str): The value to be compared with.

        Returns:
            bool: The result of the condition evaluation.
        """
        result = False
        var_value = self.variables.get(cond_var, "")
        value_is_int = False
        if cond_value.startswith('"') or cond_value.startswith("'"):
            cond_value = cond_value[1:-1]
        else:
            value_is_int = True
        if cond_comp == "eq":
            result = var_value == cond_value
        elif cond_comp == "ne":
            result = var_value != cond_value
        elif cond_comp == "gt":
            if value_is_int:
                result = int(var_value) > int(cond_value)
            else:
                result = var_value > cond_value
        elif cond_comp == "lt":
            if value_is_int:
                result = int(var_value) < int(cond_value)
            else:
                result = var_value < cond_value
        elif cond_comp == "ge":
            if value_is_int:
                result = int(var_value) >= int(cond_value)
            else:
                result = var_value >= cond_value
        elif cond_comp == "le":
            if value_is_int:
                result = int(var_value) <= int(cond_value)
            else:
                result = var_value <= cond_value
        return result

    class VARTree(lark.visitors.Interpreter):
        """
        A class for interpreting and processing a tree generated by the prompt parser in the context of initializing variables.

        Attributes:
            __ppp (object): The instance of the parent class.
            variables (dict): The dictionary to store the detected variables.

        Methods:
            commandset(node): Process a set command in the tree and add it to the dictionary of variables.
            commandif(node): Process an if command in the tree.
            start(node): Process the given tree and perform necessary operations on the found variables.
        """

        def __init__(self, ppp, prompt):
            super().__init__()
            self.__ppp = ppp
            self.__prompt = prompt

        def commandset(self, node):
            """
            Process a set command in the tree and add it to the dictionary of variables.

            Args:
                node (Node): The tree node representing the set command.

            Returns:
                None
            """
            variable = node.children[1]
            content = node.children[2]
            value = self.__prompt[content.meta.start_pos : content.meta.end_pos]
            self.__ppp.variables[variable.value] = value
            if self.__ppp.debug:
                self.__ppp.logger.info(f"Setting variable {variable} to '{value}'")

        def commandif(self, node):
            """
            Process an if command in the tree.

            Args:
                node (Node): The tree node representing the if command.

            Returns:
                None
            """
            for n in node.children:
                if len(n.children) >= 3 and n.children[1].data.type != "WHITESPACE":
                    # has a condition
                    condition = n.children[1]
                    cond_var = condition.children[0].value
                    cond_comp = condition.children[2].value
                    cond_value = condition.children[4].value
                    # there could be a whitespace node here
                    content = n.children[-1]
                    if self.__ppp.eval_condition(cond_var, cond_comp, cond_value):
                        if self.__ppp.debug:
                            conditiontext = self.__prompt[condition.meta.start_pos : condition.meta.end_pos]
                            contenttext = self.__prompt[content.meta.start_pos : content.meta.end_pos]
                            self.__ppp.logger.info(f"Applying if condition ({conditiontext}): {contenttext}")
                        self.visit(content)
                        return
                else:
                    # its an else
                    content = n.children[-1]
                    if self.__ppp.debug:
                        contenttext = self.__prompt[content.meta.start_pos : content.meta.end_pos]
                        self.__ppp.logger.info(f"Applying if else: {contenttext}")
                    self.visit(content)

        def start(self, node):
            self.visit_children(node)

    class STNTree(lark.visitors.Interpreter):
        """
        A class for interpreting and processing a tree generated by the prompt parser in the context of processing send to negative prompt commands.

        Attributes:
            __ppp (object): The instance of the parent class.
            __prompt (str): The prompt string.
            __shell (list): The list of accumulated shell elements.
            __negtags (list): The list of negative tags.
            __already_processed (list): The list of already processed content.
            add_at (dict): The dictionary to store the content to be added at different positions.
            remove (list): The list of content to be removed from the prompt.

        Methods:
            __get_numpar_value(numpar): Get the numerical value from a numpar object.
            scheduled(tree): Process a scheduling construct in the tree and add it to the accumulated shell.
            alternate(tree): Process an alternation construct in the tree and add it to the accumulated shell.
            emphasized(tree): Process an attention change construct in the tree and add it to the accumulated shell.
            deemphasized(tree): Process a decrease attention construct in the tree and add it to the accumulated shell.
            negtag(tree): Process a negative tag in the tree and add it to the list of negative tags.
            commandstn(tree): Process a send to negative command in the tree and add it to the list of negative tags.
            commandstni(tree): Process a send to negative command in the tree and add it to the list of negative tags.
            start(tree): Process the given tree and perform necessary operations on the found negative tags.
        """

        def __init__(self, ppp, prompt, add_at, insertion_at):
            super().__init__()
            self.__ppp = ppp
            self.__prompt = prompt
            self.AccumulatedShell = namedtuple("AccumulatedShell", ["type", "data", "position"])
            AccumulatedShell = self.AccumulatedShell
            self.__shell: list[AccumulatedShell] = []
            self.NegTag = namedtuple("NegTag", ["start", "end", "content", "parameters", "shell"])
            NegTag = self.NegTag
            self.__negtags: list[NegTag] = []
            self.__already_processed = []
            self.add_at = add_at
            self.insertion_at = insertion_at
            self.remove = []

        def __get_numpar_value(self, numpar):
            """
            Get the numerical value from a numpar object.

            Args:
                numpar (object): The numpar object to extract the value from.

            Returns:
                float: The numerical value extracted from the numpar object.
            """
            return float(next(x for x in numpar.children if x.type == "NUMBER").value)

        def scheduled(self, node):
            """
            Process a scheduling construct in the tree and add it to the accumulated shell.

            Args:
                node (Node): The tree node representing the scheduling construct.

            Returns:
                None
            """
            treemetaposition = (
                [node.meta.start_pos, node.meta.end_pos] if hasattr(node, "meta") and not node.meta.empty else None
            )
            if len(node.children) > 2:  # before & after
                before = node.children[0]
            else:
                before = None
            after = node.children[-2]
            numpar = node.children[-1]
            pos = self.__get_numpar_value(numpar)
            if pos >= 1:
                pos = int(pos)
            # self.__shell.append(self.AccumulatedShell("sc", pos, treemetaposition))
            if before is not None and hasattr(before, "data"):
                if self.__ppp.debug:
                    before_metaposition = (
                        [before.meta.start_pos, before.meta.end_pos]
                        if hasattr(before, "meta") and not before.meta.empty
                        else "?"
                    )
                    self.__ppp.logger.info(f"Shell scheduled before at {before_metaposition} with position {pos}")
                self.__shell.append(self.AccumulatedShell("scb", pos, treemetaposition))
                self.visit(before)
                self.__shell.pop()
            if hasattr(after, "data"):
                if self.__ppp.debug:
                    after_metaposition = (
                        [after.meta.start_pos, after.meta.end_pos]
                        if hasattr(after, "meta") and not after.meta.empty
                        else "?"
                    )
                    self.__ppp.logger.info(f"Shell scheduled after at {after_metaposition} with position {pos}")
                self.__shell.append(self.AccumulatedShell("sca", pos, treemetaposition))
                self.visit(after)
                self.__shell.pop()
            # self.__shell.pop()

        def alternate(self, node):
            """
            Process an alternation construct in the tree and add it to the accumulated shell.

            Args:
                node (Node): The tree node representing the alternation construct.

            Returns:
                None
            """
            treemetaposition = (
                [node.meta.start_pos, node.meta.end_pos] if hasattr(node, "meta") and not node.meta.empty else None
            )
            # self.__shell.append(self.AccumulatedShell("al", len(tree.children), treemetaposition))
            for i, opt in enumerate(node.children):
                if self.__ppp.debug:
                    metaposition = (
                        [opt.meta.start_pos, opt.meta.end_pos] if hasattr(opt, "meta") and not opt.meta.empty else "?"
                    )
                    self.__ppp.logger.info(f"Shell alternate at {metaposition} option {i+1}")
                if hasattr(opt, "data"):
                    self.__shell.append(
                        self.AccumulatedShell("alo", {"pos": i + 1, "len": len(node.children)}, treemetaposition)
                    )
                    self.visit(opt)
                    self.__shell.pop()
            # self.__shell.pop()

        def emphasized(self, node):
            """
            Process a attention change construct in the tree and add it to the accumulated shell.

            Args:
                node (Node): The tree node representing the attention construct.

            Returns:
                None
            """
            treemetaposition = (
                [node.meta.start_pos, node.meta.end_pos] if hasattr(node, "meta") and not node.meta.empty else None
            )
            numpar = node.children[-1]
            weight = self.__get_numpar_value(numpar) if numpar is not None else 1.1
            if self.__ppp.debug:
                self.__ppp.logger.info(f"Shell attention at {treemetaposition or '?'} with weight {weight}")
            self.__shell.append(self.AccumulatedShell("at", weight, treemetaposition))
            self.visit_children(node)
            self.__shell.pop()

        def deemphasized(self, node):
            """
            Process a decrease attention construct in the tree and add it to the accumulated shell.

            Args:
                node (Node): The tree node representing the decreased attention construct.

            Returns:
                None
            """
            weight = 0.9
            treemetaposition = (
                [node.meta.start_pos, node.meta.end_pos] if hasattr(node, "meta") and not node.meta.empty else None
            )
            if self.__ppp.debug:
                self.__ppp.logger.info(f"Shell attention at {treemetaposition or '?'} with weight {weight}")
            self.__shell.append(self.AccumulatedShell("at", weight, treemetaposition))
            self.visit_children(node)
            self.__shell.pop()

        def negtag(self, node):
            """
            Process a negative tag in the tree and add it to the list of negative tags.

            Args:
                node (Node): The tree node representing the negative tag.

            Returns:
                None
            """
            treemetaposition = (
                [node.meta.start_pos, node.meta.end_pos] if hasattr(node, "meta") and not node.meta.empty else None
            )
            negtagparameters = node.children[0]
            parameters = negtagparameters.children[0].value if negtagparameters is not None else ""
            rest = []
            for x in node.children[1::]:
                rest.append(
                    self.__prompt[x.meta.start_pos : x.meta.end_pos]
                    if hasattr(x, "meta") and not x.meta.empty
                    else x.value if hasattr(x, "value") else ""
                )
            content = "".join(rest)
            self.__negtags.append(
                self.NegTag(node.meta.start_pos, node.meta.end_pos, content, parameters, self.__shell.copy())
            )
            if self.__ppp.debug:
                self.__ppp.logger.info(
                    f"Negative tag at {treemetaposition or '?'}: {parameters or 'with no parameters'} : {self.__ppp.formatOutput(content)}"
                )

        def commandstn(self, node):
            """
            Process a send to negative command in the tree and add it to the list of negative tags.

            Args:
                node (Node): The tree node representing the stn command.

            Returns:
                None
            """
            treemetaposition = (
                [node.meta.start_pos, node.meta.end_pos] if hasattr(node, "meta") and not node.meta.empty else None
            )
            negtagparameters = node.children[1]
            if negtagparameters is not None:
                if hasattr(negtagparameters, "children"):
                    parameters = negtagparameters.children[0].value
                else:
                    parameters = negtagparameters.value
            else:
                parameters = ""
            rest = []
            for x in node.children[2::]:
                rest.append(
                    self.__prompt[x.meta.start_pos : x.meta.end_pos]
                    if hasattr(x, "meta") and not x.meta.empty
                    else x.value if hasattr(x, "value") else ""
                )
            content = "".join(rest)
            self.__negtags.append(
                self.NegTag(node.meta.start_pos, node.meta.end_pos, content, parameters, self.__shell.copy())
            )
            if self.__ppp.debug:
                self.__ppp.logger.info(
                    f"Negative tag at {treemetaposition or '?'}: {parameters or 'with no parameters'} : {self.__ppp.formatOutput(content)}"
                )

        def commandstni(self, node):
            self.commandstn(node)

        def start(self, node):
            """
            Process the given tree and perform necessary operations on the found negative tags.

            Args:
                node: The tree to be processed.

            Returns:
                None
            """
            self.visit_children(node)
            # process the found negative tags
            for negtag in self.__negtags:
                if self.__ppp.stn_join_attention:
                    # join consecutive attention elements
                    for i in range(len(negtag.shell) - 1, 0, -1):
                        if negtag.shell[i].type == "at" and negtag.shell[i - 1].type == "at":
                            negtag.shell[i - 1] = self.AccumulatedShell(
                                "at",
                                math.floor(100 * negtag.shell[i - 1].data * negtag.shell[i].data)
                                / 100,  # we limit the new weight to two decimals
                                negtag.shell[i - 1].position,
                            )
                            negtag.shell.pop(i)
                start = ""
                end = ""
                for s in negtag.shell:
                    match s.type:
                        case "at":
                            if s.data == 0.9:
                                start += "["
                                end = "]" + end
                            elif s.data == 1.1:
                                start += "("
                                end = ")" + end
                            else:
                                start += "("
                                end = f":{s.data})" + end
                        # case "sc":
                        case "scb":
                            start += "["
                            end = f"::{s.data}]" + end
                        case "sca":
                            start += "["
                            end = f":{s.data}]" + end
                        # case "al":
                        case "alo":
                            start += "[" + ("|" * int(s.data["pos"] - 1))
                            end = ("|" * int(s.data["len"] - s.data["pos"])) + "]" + end
                content = start + negtag.content + end
                position = negtag.parameters or "s"
                if position.startswith("i"):
                    n = int(position[1])
                    self.insertion_at[n] = [negtag.start, negtag.end]
                elif len(content) > 0:
                    if content not in self.__already_processed:
                        if self.__ppp.stn_ignore_repeats:
                            self.__already_processed.append(content)
                        if self.__ppp.debug:
                            self.__ppp.logger.info(
                                f"Adding content at position {position}: {self.__ppp.formatOutput(content)}"
                            )
                        if position == "e":
                            self.add_at["end"].append(content)
                        elif position.startswith("p"):
                            n = int(position[1])
                            self.add_at["insertion_point"][n].append(content)
                        else:  # position == "s" or invalid
                            self.add_at["start"].append(content)
                    else:
                        self.__ppp.logger.warning(f"Ignoring repeated content: {self.__ppp.formatOutput(content)}")
                # remove from prompt
                self.remove.append([negtag.start, negtag.end])

    def __find_tags(self, prompt, negative_prompt):
        """
        Finds tags in the given prompt and returns the modified prompt and tag information.

        Args:
            prompt (str): The input prompt.

        Returns:
            tuple: A tuple containing the modified prompt and tag information.

        """
        add_at = {"start": [], "insertion_point": [[] for x in range(10)], "end": []}
        insertion_at = [None for x in range(10)]

        tree = self.__parser_complete.parse(prompt)
        readtree = self.STNTree(self, prompt, add_at, insertion_at)
        readtree.visit(tree)
        for r in readtree.remove[::-1]:
            prompt = prompt[: r[0]] + prompt[r[1] :]
        add_at = readtree.add_at  # we only use the additions from the prompt

        tree = self.__parser_complete.parse(negative_prompt)
        readtree = self.STNTree(self, negative_prompt, add_at, insertion_at)
        readtree.visit(tree)
        insertion_at = readtree.insertion_at  # we only use the insertion positions from the negative prompt

        if self.debug:
            self.logger.info(f"New negative additions: {add_at}")
            self.logger.info(f"New negative indexes: {insertion_at}")
        return prompt, negative_prompt, add_at, insertion_at

    def __add_to_insertion_points(self, negative_prompt, add_at_insertion_point, insertion_at):
        """
        Adds the negative prompt to the insertion points.

        Args:
            negative_prompt (str): The negative prompt to be added.
            add_at_insertion_point (list): A list of insertion points.
            insertion_at (list): A list of insertion blocks.

        Returns:
            str: The modified negative prompt.
        """
        ordered_range = sorted(
            range(10), key=lambda x: insertion_at[x][0] if insertion_at[x] is not None else float("-inf"), reverse=True
        )
        for n in ordered_range:
            if insertion_at[n] is not None:
                ipp = insertion_at[n][0]
                ipl = insertion_at[n][1] - insertion_at[n][0]
                if negative_prompt[ipp - len(self.stn_separator) : ipp] == self.stn_separator:
                    ipp -= len(self.stn_separator)  # adjust for existing start separator
                    ipl += len(self.stn_separator)
                add_at_insertion_point[n].insert(0, negative_prompt[:ipp])
                if negative_prompt[ipp + ipl : ipp + ipl + len(self.stn_separator)] == self.stn_separator:
                    ipl += len(self.stn_separator)  # adjust for existing end separator
                endPart = negative_prompt[ipp + ipl :]
                if len(endPart) > 0:
                    add_at_insertion_point[n].append(endPart)
                negative_prompt = self.stn_separator.join(add_at_insertion_point[n])
            else:
                ipp = 0
                if negative_prompt.startswith(self.stn_separator):
                    ipp = len(self.stn_separator)
                add_at_insertion_point[n].append(negative_prompt[ipp:])
                negative_prompt = self.stn_separator.join(add_at_insertion_point[n])
        return negative_prompt

    def __add_to_start(self, negative_prompt, add_at_start):
        """
        Adds the elements in `add_at_start` list to the start of the `negative_prompt` string.

        Args:
            negative_prompt (str): The original negative prompt string.
            add_at_start (list): The list of elements to be added at the start of the negative prompt.

        Returns:
            str: The updated negative prompt string with the elements added at the start.
        """
        if len(negative_prompt) > 0:
            ipp = 0
            if negative_prompt.startswith(self.stn_separator):
                ipp = len(self.stn_separator)  # adjust for existing end separator
            add_at_start.append(negative_prompt[ipp:])
        negative_prompt = self.stn_separator.join(add_at_start)
        return negative_prompt

    def __add_to_end(self, negative_prompt, add_at_end):
        """
        Adds the elements in `add_at_end` list to the end of `negative_prompt` string.

        Args:
            negative_prompt (str): The original negative prompt string.
            add_at_end (list): The list of elements to be added at the end of `negative_prompt`.

        Returns:
            str: The updated negative prompt string with elements added at the end.
        """
        if len(negative_prompt) > 0:
            ipl = len(negative_prompt)
            if negative_prompt.endswith(self.stn_separator):
                ipl -= len(self.stn_separator)  # adjust for existing start separator
            add_at_end.insert(0, negative_prompt[:ipl])
        negative_prompt = self.stn_separator.join(add_at_end)
        return negative_prompt

    def __sendtonegative(self, prompt, negative_prompt):
        """
        Modifies the prompt and negative_prompt by moving content from the prompt to the negative prompt.

        Args:
            prompt (str): The prompt.
            negative_prompt (str): The negative prompt.

        Returns:
            tuple: A tuple containing the modified prompt and negative_prompt.
        """
        if self.debug:
            self.logger.info("Doing send-to-negative")
        prompt, negative_prompt, add_at, insertion_at = self.__find_tags(prompt, negative_prompt)
        negative_prompt = self.__add_to_insertion_points(negative_prompt, add_at["insertion_point"], insertion_at)
        if len(add_at["start"]) > 0:
            negative_prompt = self.__add_to_start(negative_prompt, add_at["start"])
        if len(add_at["end"]) > 0:
            negative_prompt = self.__add_to_end(negative_prompt, add_at["end"])
        if self.debug:
            self.logger.info(f"prompt after send-to-negative: {self.formatOutput(prompt)}")
            self.logger.info(f"negative_prompt after send-to-negative: {self.formatOutput(negative_prompt)}")
        return prompt, negative_prompt

    class TransformerTree(lark.visitors.Transformer_NonRecursive):
        """
        Transformer class for detecting wildcards and/or cleaning up a prompt parsed into a tree.

        This class provides methods for transforming different constructs in a parse tree
        based on certain conditions. It is used for detecting wildcards and cleaning up invalid
        or empty constructs in the parse tree.

        Args:
            ppp (object): An instance of the parent class `ppp`.
            phase (str): The phase of the transformation.

        Attributes:
            __ppp (object): An instance of the parent class `ppp`.
            __phase (str): The phase of the transformation.
            detectedWildcards (list): A list of detected wildcards.

        Methods:
            promptcomp(children): Replicates prompt composition constructs.
            scheduled(children): Replicates or removes scheduling constructs based on conditions.
            alternate(children): Replicates or removes alternation constructs based on conditions.
            emphasized(children): Replicates or removes attention constructs based on conditions.
            deemphasized(children): Replicates or removes attention constructs based on conditions.
            extranetworktag(children): Replicates extra network constructs.
            numpar(children): Cleans up number parameter.
            negtag(children): Replicates or removes negative tag constructs based on conditions.
            commandstn(children): Replicates or removes send to negative constructs based on conditions.
            commandstni(children): Replicates or removes send to negative constructs based on conditions.
            commandif(children): Replicates or removes if constructs based on conditions.
            commandset(children): Replicates or removes set constructs based on conditions.
            commandecho(children): Replicates or removes echo constructs based on conditions.
            wildcard(children): Replicates or removes wildcard constructs based on conditions.
            choices(children): Replicates or removes choices constructs based on conditions.
            choice(children): Replicates choices.
            plain(children): Cleans up plain text based on conditions.
            __default__(data, children, meta): Default method for joining children and cleaning up text based on conditions.
        """

        def __init__(self, ppp, phase="cleanup"):
            super().__init__(visit_tokens=True)
            self.__ppp = ppp
            self.__phase = phase
            self.detectedWildcards = []

        def promptcomp(self, children):
            r = children[0]
            if len(children) > 1:
                if children[1] is not None:
                    r += f":{children[1]}"
                for i in range(2, len(children), 3):
                    if self.__phase == "cleanup" and self.__ppp.cup_ands:
                        r = re.sub(r"[, ]+$", "\n" if self.__ppp.cup_ands_eol else " ", r)
                    if r[-1:].isalnum():  # add space if needed
                        r += " "
                    r += "AND"
                    t = children[i + 1]
                    if self.__phase == "cleanup" and self.__ppp.cup_ands:
                        t = re.sub(r"^[, ]+", " ", t)
                    if t[0:1].isalnum():  # add space if needed
                        r += " "
                    r += t
                    if children[i + 2] is not None:
                        r += f":{children[i+2]}"
            if self.__ppp.debug:
                self.__ppp.logger.info(f"{self.__phase} TransformerTree.promptcomp: {r}")
            return r

        def scheduled(self, children):
            if len(children) == 0 and self.__phase == "cleanup" and self.__ppp.cup_emptyconstructs:
                r = ""  # remove invalid scheduling construct (probably this is not reachable)
            else:
                # replicate scheduling construct
                if len(children) > 0 and children[0] is None:
                    r = f"[{':'.join(children[1:])}]"
                else:
                    r = f"[{':'.join(children)}]"
            if self.__ppp.debug:
                self.__ppp.logger.info(f"{self.__phase} TransformerTree.scheduled: {r}")
            return r

        def alternate(self, children):
            if len(children) == 0 and self.__phase == "cleanup" and self.__ppp.cup_emptyconstructs:
                r = ""  # remove invalid alternation construct (probably this is not reachable)
            else:
                r = f"[{'|'.join(children)}]"  # replicate alternation construct
            if self.__ppp.debug:
                self.__ppp.logger.info(f"{self.__phase} TransformerTree.alternate: {r}")
            return r

        def emphasized(self, children):
            if (
                (len(children) == 0 or children[0] == "")
                and self.__phase == "cleanup"
                and self.__ppp.cup_emptyconstructs
            ):
                r = ""  # remove empty attention construct
            else:
                if len(children) > 1 and children[1] is not None:
                    r = f"({children[0]}:{children[1]})"  # replicate attention construct with weight
                else:
                    r = f"({children[0]})"  # replicate attention construct without weight
            if self.__ppp.debug:
                self.__ppp.logger.info(f"{self.__phase} TransformerTree.emphasized: {r}")
            return r

        def deemphasized(self, children):
            if (
                (len(children) == 0 or children[0] == "")
                and self.__phase == "cleanup"
                and self.__ppp.cup_emptyconstructs
            ):
                r = ""  # remove empty attention construct (invalid scheduling or alternation constructs end up here too?)
            else:
                r = f"[{children[0]}]"  # replicate attention construct
            if self.__ppp.debug:
                self.__ppp.logger.info(f"{self.__phase} TransformerTree.deemphasized: {r}")
            return r

        def extranetworktag(self, children):
            if self.__phase == "removecontent" and self.__ppp.rem_removeextranetworktags:
                r = ""  # remove extra network construct
            else:
                r = f"<{children[0]}>"  # replicate extra network construct
            if self.__ppp.debug:
                self.__ppp.logger.info(f"{self.__phase} TransformerTree.deemphasized: {r}")
            return r

        def numpar(self, children):
            r = next(x for x in children if x.type == "NUMBER").value.strip()  # clean up number parameter
            if self.__ppp.debug:
                self.__ppp.logger.info(f"{self.__phase} TransformerTree.numpar: {r}")
            return r

        def negtag(self, children):
            if self.__phase == "cleanup":
                r = ""  # remove negative tag construct (there shouldn't be any at this point)
            else:
                parameters = f"!{children[0]}!" if children[0] is not None else ""
                content = "".join(children[1::])
                r = f"<!{parameters}{content}!>"  # replicate negative tag construct
            if self.__ppp.debug:
                self.__ppp.logger.info(f"{self.__phase} TransformerTree.negtag: {r}")
            return r

        def commandstn(self, children):
            if self.__phase == "cleanup":
                r = ""  # remove send to negative command construct (there shouldn't be any at this point)
            else:
                parameters = " " + children[1] if children[1] is not None else ""
                content = "".join(children[2::])
                r = f"<ppp:stn{parameters}>{content}<ppp:/stn>"  # replicate send to negative command construct
            if self.__ppp.debug:
                self.__ppp.logger.info(f"{self.__phase} TransformerTree.commandstn: {r}")
            return r

        def commandstni(self, children):
            if self.__phase == "cleanup":
                r = ""  # remove send to negative command construct (there shouldn't be any at this point)
            else:
                parameters = " " + children[1] if children[1] is not None else ""
                r = f"<ppp:stn{parameters}>"  # replicate send to negative command construct
            if self.__ppp.debug:
                self.__ppp.logger.info(f"{self.__phase} TransformerTree.commandstni: {r}")
            return r

        def commandset(self, children):
            if self.__phase == "removecontent":
                r = ""
            else:
                r = f"<ppp:set {children[1]}>{children[2]}<ppp:/set>"  # replicate set construct
            if self.__ppp.debug:
                self.__ppp.logger.info(f"{self.__phase} TransformerTree.commandset: {r}")
            return r
        
        def commandecho(self, children):
            if self.__phase == "removecontent":
                r = self.__ppp.variables.get(children[1], "")
            else:
                r = f"<ppp:echo>{children[1]}<ppp:/echo>"
            if self.__ppp.debug:
                self.__ppp.logger.info(f"{self.__phase} TransformerTree.commandecho: {r}")
            return r

        def commandif(self, children):
            if self.__phase == "removecontent":
                selectedcontent = ""
                for n in children:
                    if len(n) >= 3 and isinstance(n[1], list):
                        # has a condition
                        condition = n[1]
                        cond_var = condition[0].value
                        cond_comp = condition[2].value
                        cond_value = condition[4].value
                        # there could be a whitespace node here
                        content = n[-1]
                        if self.__ppp.eval_condition(cond_var, cond_comp, cond_value):
                            selectedcontent = content
                            break
                    else:
                        # its an else
                        selectedcontent = n[-1]
                        break
                r = selectedcontent
            else:
                r = f"{''.join(children)}<ppp:/if>"
            if self.__ppp.debug:
                self.__ppp.logger.info(f"{self.__phase} TransformerTree.commandif: {r}")
            return r

        def commandif_if(self, children):
            if self.__phase == "removecontent":
                return children
            return f"<ppp:if {children[1]}>{children[2]}"  # replicate if construct

        def commandif_elif(self, children):
            if self.__phase == "removecontent":
                return children
            return f"<ppp:elif {children[1]}>{children[2]}"  # replicate elif construct

        def commandif_else(self, children):
            if self.__phase == "removecontent":
                return children
            return f"<ppp:else>{children[1]}"  # replicate else construct

        def condition(self, children):
            if self.__phase == "removecontent":
                return children
            return "".join(children)  # replicate condition rule

        def wildcard(self, children):
            r = f"__{children[0]}__"  # replicate wildcard construct
            self.detectedWildcards.append(r)
            if self.__phase == "wildcards" and self.__ppp.ifwildcards == self.__ppp.IFWILDCARDS_CHOICES["remove"]:
                r = ""
            if self.__ppp.debug:
                self.__ppp.logger.info(f"{self.__phase} TransformerTree.wildcard: {r}")
            return r

        def choices(self, children):
            r = "{" + "|".join(children) + "}"  # replicate wildcard choices construct
            self.detectedWildcards.append(r)
            if self.__phase == "wildcards" and self.__ppp.ifwildcards == self.__ppp.IFWILDCARDS_CHOICES["remove"]:
                r = ""
            if self.__ppp.debug:
                self.__ppp.logger.info(f"{self.__phase} TransformerTree.choices: {r}")
            return r

        def choice(self, children):
            r = children[0]  # replicate choice
            if self.__ppp.debug:
                self.__ppp.logger.info(f"{self.__phase} TransformerTree.choice: {r}")
            return r

        def plain(self, children):
            r = children[0].value
            if self.__phase == "cleanup":
                r = self.__ppp.cleanup_text(r)  # clean up plain text
            if self.__ppp.debug:
                self.__ppp.logger.info(f"{self.__phase} TransformerTree.plain: {r}")
            return r

        def __default__(self, data, children, meta):
            joined = "".join(children)  # join all children
            if self.__phase == "cleanup" and not re.match(r"[([<{]", joined):
                # take care of cleaning the joints only if there are no constructs that can be affected
                joined = self.__ppp.cleanup_text(joined)
            if self.__ppp.debug:
                self.__ppp.logger.info(f"{self.__phase} TransformerTree.default: {joined}")
            return joined

    def __removecontent(self, prompt, negative_prompt):
        """
        Removes content in the prompt and negative prompt.

        Args:
            prompt (str): The original prompt.
            negative_prompt (str): The negative prompt.

        Returns:
            tuple: A tuple containing the processed prompt and negative prompt.
        """

        self.variables = {}
        self.variables["_sd"] = (
            "sd1"
            if self.processing.sd_model.is_sd1
            else "sd2" if self.processing.sd_model.is_sd2 else "sdxl" if self.processing.sd_model.is_sdxl else ""
        )

        transformtree = self.TransformerTree(self, phase="removecontent")
        try:
            if self.debug:
                self.logger.info("Removing content in the prompt")
            prompt_tree = self.__parser_complete.parse(prompt)
            vartree = self.VARTree(self, prompt)
            vartree.visit(prompt_tree)
            prompt = transformtree.transform(prompt_tree)
        except Exception as e:  # pylint: disable=broad-except
            self.logger.warning("parsing failed on prompt!: %s", e)
        try:
            if self.debug:
                self.logger.info("Removing content in the negative prompt")
            negativeprompt_tree = self.__parser_complete.parse(negative_prompt)
            vartree = self.VARTree(self, negative_prompt)
            vartree.visit(negativeprompt_tree)
            negative_prompt = transformtree.transform(negativeprompt_tree)
        except Exception as e:  # pylint: disable=broad-except
            self.logger.warning("parsing failed on negative prompt!: %s", e)

        if self.debug:
            self.logger.info(f"prompt after content removal: {self.formatOutput(prompt)}")
            self.logger.info(f"negative_prompt after content removal: {self.formatOutput(negative_prompt)}")
        return prompt, negative_prompt

    def __cleanup(self, prompt, negative_prompt):
        """
        Cleans up the prompt and negative prompt by removing extra spaces, empty constructs, and extra separators.

        Args:
            prompt (str): The original prompt.
            negative_prompt (str): The negative prompt.

        Returns:
            tuple: A tuple containing the cleaned up prompt and negative prompt.
        """

        transformtree = self.TransformerTree(self, phase="cleanup")
        try:
            if self.debug:
                self.logger.info("Cleaning the prompt")
            prompt_tree = self.__parser_complete.parse(prompt)
            prompt = self.trim_text(transformtree.transform(prompt_tree))
        except Exception as e:  # pylint: disable=broad-except
            self.logger.warning("Parsing failed on prompt!: %s", e)
        try:
            if self.debug:
                self.logger.info("Cleaning the negative prompt")
            negativeprompt_tree = self.__parser_complete.parse(negative_prompt)
            negative_prompt = self.trim_text(transformtree.transform(negativeprompt_tree))
        except Exception as e:  # pylint: disable=broad-except
            self.logger.warning("Parsing failed on negative prompt!: %s", e)

        if self.debug:
            self.logger.info(f"prompt after cleanup: {self.formatOutput(prompt)}")
            self.logger.info(f"negative_prompt after cleanup: {self.formatOutput(negative_prompt)}")
        return prompt, negative_prompt

    def cleanup_text(self, text):
        """
        Cleans up the given text by removing extra separators, breaks, and spaces. This is called for plain text only or when there are no constructs.

        Args:
            text (str): The text to be cleaned up.

        Returns:
            str: The cleaned up text.
        """
        # NOTE: we can't use start/end of line regex since the text might only be a part of a larger line due to the parser
        if self.cup_extraseparators:
            #
            # sendtonegative separator
            #
            escapedSeparator = re.escape(self.stn_separator)
            # collapse separators
            text = re.sub(r"(?:\s*" + escapedSeparator + r"\s*){2,}", self.stn_separator, text)
            #
            # regular comma separator
            #
            # collapse separators
            text = re.sub(r"(?:\s*,\s*){2,}", ", ", text)
        if self.cup_breaks:
            # collapse separators and commas before BREAK
            text = re.sub(r"[, ]+BREAK\b", " BREAK", text)
            # collapse separators and commas after BREAK
            text = re.sub(r"\bBREAK[, ]+", "BREAK ", text)
            # collapse separators and commas around BREAK
            text = re.sub(r"[, ]+BREAK[, ]+", " BREAK ", text)
            # collapse BREAKs
            text = re.sub(r"\bBREAK(?:\s+BREAK)+\b", " BREAK ", text)
        if self.cup_extraspaces:
            # remove spaces before comma
            text = re.sub(r"[ ]+,", ",", text)
            # collapse spaces
            text = re.sub(r"[ ]{2,}", " ", text)
        return text

    def trim_text(self, text):
        """
        Trims the given text based on the specified cleanup options. This is only called for the reconstructed prompt.

        Args:
            text (str): The text to be trimmed.

        Returns:
            str: The trimmed text.
        """
        # NOTE: here we can only do cleanups that can be done on the whole text, including inside constructs and around them
        if self.cup_extraseparators:
            #
            # sendtonegative separator
            #
            escapedSeparator = re.escape(self.stn_separator)
            # remove duplicate separator after starting parenthesis or bracket
            text = re.sub(r"(\s*" + escapedSeparator + r"\s*[([])\s*" + escapedSeparator + r"\s*", r"\1", text)
            # remove before colon or ending parenthesis or bracket
            text = re.sub(r"\s*" + escapedSeparator + r"\s*([:)\]]\s*" + escapedSeparator + r"\s*)", r"\1", text)
        if self.cup_extraseparators2:
            # remove at start of prompt or line
            text = re.sub(r"^(?:\s*" + escapedSeparator + r"\s*)", "", text, flags=re.MULTILINE)
            # remove at end of prompt or line
            text = re.sub(r"(?:\s*" + escapedSeparator + r"\s*)$", "", text, flags=re.MULTILINE)
        if self.cup_extraseparators:
            #
            # regular comma separator
            #
            # remove duplicate separators after starting parenthesis or bracket
            text = re.sub(r"(\s*,\s*[([])\s*,\s*", r"\1", text)
            # remove duplicate separators before colon or ending parenthesis or bracket
            text = re.sub(r"\s*,\s*([:)\]]\s*,\s*)", r"\1", text)
        if self.cup_extraseparators2:
            # remove at start of prompt or line
            text = re.sub(r"^\s*,\s*", "", text, flags=re.MULTILINE)
            # remove at end of prompt or line
            text = re.sub(r"\s*,\s*$", "", text, flags=re.MULTILINE)
        if self.cup_breaks_eol:
            # replace spaces before break with EOL
            text = re.sub(r"[, ]+BREAK\b", "\nBREAK", text)
        if self.cup_breaks:
            # remove spaces between start of line and BREAK
            text = re.sub(r"^[ ]+BREAK\b", "BREAK", text, flags=re.MULTILINE)
            # remove spaces between BREAK and end of line
            text = re.sub(r"\bBREAK[ ]+$", "BREAK", text, flags=re.MULTILINE)
            # remove at start of prompt
            text = re.sub(r"\ABREAK\b", "", text)
            # remove at end of prompt
            text = re.sub(r"\bBREAK\Z", "", text)
        if self.cup_ands:
            # collapse ANDs with space after
            text = re.sub(r"\bAND(?:\s+AND)+\s+", "AND ", text)
            # collapse ANDs without space after
            text = re.sub(r"\bAND(?:\s+AND)+\b", "AND", text)
            # collapse separators and spaces before ANDs
            text = re.sub(r"[, ]+AND\b", " AND", text)
            # collapse separators and spaces after ANDs
            text = re.sub(r"\bAND[, ]+", "AND ", text)
            # remove at start of prompt
            text = re.sub(r"\AAND\b", "", text)
            # remove at end of prompt
            text = re.sub(r"\bAND\Z", "", text)
        if self.cup_extranetworktags:
            #
            # all cases since we can't find them inside plain text
            #
            # remove spaces before <
            text = re.sub(r"\B\s+<(?!!)", "<", text)
            # remove spaces after >
            text = re.sub(r"(?<!!)>\s+\B", ">", text)
        if self.cup_extraspaces:
            # remove extra whitespace after starting parenthesis or bracket
            text = re.sub(r"([,\.;\s]+[([])\s+", r"\1", text)
            # remove extra whitespace before ending parenthesis or bracket
            text = re.sub(r"\s+([)\]][,\.;\s]+)", r"\1", text)
            # collapse spaces
            # text = re.sub(r"[ ]{2,}", " ", text)
            # remove spaces at start and end
            text = text.strip()
        return text

    def __findwildcards(self, prompt, negative_prompt):
        """
        Find and process wildcards in the prompt and negative_prompt strings.

        Args:
            prompt (str): The prompt string.
            negative_prompt (str): The negative prompt string.

        Returns:
            tuple: A tuple containing the processed prompt and negative_prompt strings.
        """

        p_transformtree = self.TransformerTree(self, phase="wildcards")
        try:
            if self.debug:
                self.logger.info("Wildcard processing in the prompt")
            p_tree = self.__parser_complete.parse(prompt)
            prompt = p_transformtree.transform(p_tree)
        except Exception as e:  # pylint: disable=broad-except
            self.logger.warning("Parsing failed in prompt!: %s", e)

        np_transformtree = self.TransformerTree(self, phase="wildcards")
        try:
            if self.debug:
                self.logger.info("Wildcard processing in the negative prompt")
            np_tree = self.__parser_complete.parse(negative_prompt)
            negative_prompt = np_transformtree.transform(np_tree)
        except Exception as e:  # pylint: disable=broad-except
            self.logger.warning("Parsing failed in negative prompt!: %s", e)

        foundP = False
        foundNP = False
        if len(p_transformtree.detectedWildcards) > 0:
            foundP = True
            self.logger.info(f"Found wildcards in prompt: {p_transformtree.detectedWildcards}")
        if len(np_transformtree.detectedWildcards) > 0:
            foundNP = True
            self.logger.info(f"Found wildcards in negative prompt: {np_transformtree.detectedWildcards}")

        if foundP or foundNP:
            if self.ifwildcards == self.IFWILDCARDS_CHOICES["warn"]:
                prompt = self.WILDCARD_WARNING + prompt
            elif self.ifwildcards == self.IFWILDCARDS_CHOICES["stop"]:
                self.logger.error("Found unprocessed wildcards! Stopping the generation.")
                if foundP:
                    prompt = self.WILDCARD_STOP + prompt
                if foundNP:
                    negative_prompt = self.WILDCARD_STOP + negative_prompt
                if hasattr(self.script, "ppp_interrupt"):
                    self.script.ppp_interrupt()
            if self.debug:
                self.logger.info(f"prompt after wildcards: {self.formatOutput(prompt)}")
                self.logger.info(f"negative_prompt after wildcards: {self.formatOutput(negative_prompt)}")
        return prompt, negative_prompt

    def process_prompt(self, original_prompt, original_negative_prompt):
        """
        Process the prompt and negative prompt by moving content to the negative prompt, and cleaning up.

        Args:
            original_prompt (str): The original prompt.
            original_negative_prompt (str): The original negative prompt.

        Returns:
            tuple: A tuple containing the processed prompt and negative prompt.
        """
        try:
            self.variables = {}
            prompt = original_prompt
            negative_prompt = original_negative_prompt
            self.debug = getattr(self.opts, "ppp_gen_debug", False)
            if not self.is_i2i or self.stn_doi2i or self.cup_doi2i:
                if self.debug:
                    self.logger.info(f"Input prompt: {self.formatOutput(prompt)}")
                    p_tree = self.__parser_complete.parse(prompt)
                    self.logger.info(f"Tree from prompt:\n{p_tree.pretty()}")
                    self.logger.info(f"Input negative_prompt: {self.formatOutput(negative_prompt)}")
                    np_tree = self.__parser_complete.parse(negative_prompt)
                    self.logger.info(f"Tree from negative prompt:\n{np_tree.pretty()}")

                prompt, negative_prompt = self.__removecontent(prompt, negative_prompt)

                if self.ifwildcards != self.IFWILDCARDS_CHOICES["ignore"]:
                    prompt, negative_prompt = self.__findwildcards(prompt, negative_prompt)

                if not self.is_i2i or self.stn_doi2i:
                    prompt, negative_prompt = self.__sendtonegative(prompt, negative_prompt)

                # pylint: disable-next=too-many-boolean-expressions
                if (not self.is_i2i or self.cup_doi2i) and (
                    self.cup_extraspaces
                    or self.cup_emptyconstructs
                    or self.cup_extraseparators
                    or self.cup_extraseparators2
                    or self.cup_breaks
                    or self.cup_breaks_eol
                    or self.cup_ands
                    or self.cup_ands_eol
                    or self.cup_extranetworktags
                ):
                    prompt, negative_prompt = self.__cleanup(prompt, negative_prompt)

                # Check for constructs not processed due to parsing problems
                if (
                    prompt.find("<ppp:") >= 0
                    or negative_prompt.find("<ppp:") >= 0
                    or prompt.find("<!") >= 0
                    or negative_prompt.find("<!") >= 0
                ):
                    self.logger.error(
                        "Found unprocessed constructs in prompt or negative prompt! Stopping the generation."
                    )
                    self.logger.info(f"prompt: {self.formatOutput(prompt)}")
                    self.logger.info(f"negative_prompt: {self.formatOutput(negative_prompt)}")
                    prompt = self.UNPROCESSED_STOP + prompt
                    if hasattr(self.script, "ppp_interrupt"):
                        self.script.ppp_interrupt()

            return prompt, negative_prompt
        except Exception as e:  # pylint: disable=broad-exception-caught
            self.logger.exception(e)
            return original_prompt, original_negative_prompt
